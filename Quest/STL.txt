З чого складається STL?
/
Алгоритмы
Итераторы
Контейнеры
Предикаты, Функторы
Алокаторы
----------------------------------------------------------------------------------------------------------
Які алгоритми застосовували з STL? 
В чому перевага використання алгоритмів перед власноруч написаними функціями?
/
алгоритми поиска, алгоритмы сортировки
std::find
std::for_each
std::sort
std::swap

Библиотека алгоритмов определяет функции для различных целей 
(например, поиск, сортировка, подсчёт, манипулирование), которые работают с диапазонами элементов. 

Алгоритм (в контексте STL) это функции которая работает с контейнером через итератор
потому что итераторы предоставляют абстракцию по отношению ко всем контейнерам

поэтому алгоиртмы работают с любыми типами данных, и с классами, если для класса предусмотрена
опреденная операция
----------------------------------------------------------------------------------------------------------
Розкажіть про контейнери стандартної бібліотеки vector, list, map, unordered_map.
/
vector - данимический массив под капотом(из минусов перевыделение памяти, капасити)
list - Двухсвязный список под капотом (узел указывает на следущий и предыдущий)
к примеру из плюсов это вставка в середину(так как меняются указатели)
map - хранит в себе ключ и значение, сложность - алгоритмическая
unordered_map - неупорядоченный контейнер, если мап отсортированн, то этот нет
----------------------------------------------------------------------------------------------------------
Які знаєте типи ітераторів? Чим вони відрізняються? В яких контейнерах використовуються?
/
Категории итераторов определяют действия которые можно сделать с итератором.
/
Итератор - шаблонный класс который имитирует указатель. Используется с контейнерами
интерфейс, предоставляющий доступ к элементам коллекции(контейнера) и навигацию по ним.
Класс(шаблон класса), который имитирует указатель на елементы контейнера
были придуманны что бы мы могли писать функции, которые работают со всеми контейнерами одинаков
Итератор — структура данных, которая «указывает» на некоторый элемент контейнера, 
и (для некоторых контейнеров) умеет переходить к предыдущему/следующему элементу.
/
для чтения	Читают значения с движением вперед. Могут быть инкрементированы, сравнены и разыменованы.

для записи	Пишут значения с движением вперед. Могут быть инкрементированы и разыменованы.

однонаправленные	Читают или пишут значения с движением вперед. 
Комбинируют функциональность предыдущих двух типов с возможностью сохранять значение итератора.
Прямые итераторы - это итераторы односвязных списков, например std::forward_list.

двунаправленные	Читают и пишут значения с движением вперед или назад. 
Похожи на однонаправленные, но их также можно инкрементировать и декрементировать.
Пример: итераторы двусвязных списков (std::list), деревьев (std::set).

с произвольным доступом	Читают и пишут значения с произвольным доступом. 
Самые мощные итераторы, сочетающие функциональность двунаправленных итераторов и возможность 
выполнения арифметики указателей и сравнений указателей.
Пример: итераторы массивов (std::vector), указатели.

обратные итераторы с произвольным доступом, или двунаправленные, движущиеся в обратном направлении.
----------------------------------------------------------------------------------------------------------
разница между set and map
/
set = ключ и есть значение (отсортированн) (только одик ключ, без дубликатов)
map = ключ и значение (отсортированн) (только одик ключ, без дубликатов)
unordered_multimap (ключи в произвольнов порядке)(могут иметь дубликаты)
----------------------------------------------------------------------------------------------------------
Що таке ідіома remove-erase?
/
с её помощью мы можем удалить определенные елементы, к примеру в векторе и сложность всегда будет О(n)
----------------------------------------------------------------------------------------------------------
Як отримати найменше значення типу?
/
----------------------------------------------------------------------------------------------------------
Яка різниця між std::map та std::hashmap?
/
std::map держит данные в отсортированном по ключу виде, в отличие от std::unordered_map. Если вам нужно 
это свойство, вам нужен std::map. Если нет, достаточно и std::unordered_map.
(Как следствие отсортированности, например, в std::map есть функция lower_bound, 
которой нет в std::unordered_map.)
----------------------------------------------------------------------------------------------------------
Як підрахувати кількість елементів у std::list?
/
std::list<T>::size()
----------------------------------------------------------------------------------------------------------
Що таке складність алгоритму та від чого вона залежить?
/
это время на выполнения Insert(вставка), Access(доступ к елементу), Erase(удаление), Search(поиск)

есть константная сложнось О(1)
алгоритмическая О(log n)
линейнай О(n)
и т.д.

к примеру доступ к елементу вектора будет константой сложностью, потому что arr(адресс первого елемента) + size
в независимости от количества елементов в векторе
----------------------------------------------------------------------------------------------------------
В чому різниця між vector та list і у яких випадках їх краще використовувати?
/
Нет, не правильно. В массиве данные хранятся последовательно. 
Доступ к произвольному элементу массива происходит быстрее, чем доступ к произвольному элементу списка.

а к примеру если нужно добавить елемент в центр массива, то лучше использовать лист.
так как идет перепривязка адрессов, а у вектора если капасити = сайз, то будет перевыделение +
конечно же смещение всех значений с правой стороны на одну позицию
/
vector:
динамический массив
Insert: Вставка O(1) push_back. another O(n) (амортизированая скорость)
Access: Доступ до елементу О(1)
Erase: Удаление O(1) pop_back. another O(n) (амортизированая скорость)
Search: поиск О(n) линейный поиск
у вектора есть операция перегруженная [], у листа = нету если много поиска, то лучше вектор

||

list:
Двухсвязный список
Insert: O(1) перепривязывание соседних адресов
Access: O(1) Доступ только по итератору(когда он есть). О(n) если нужно найти значение
Erase: O(1) перепривязывание соседних адресов
Search: O(n) линейный поиск
++
std::list vs std::vector
вставка или удаление у std::vector = линейная сложность О(n)
вставка или удаление у std::list = Константная сложность О(1)
операция обращения по индексу = std::vector = константная сложность
операция обращения по индексу = std::list = линейная сложность
----------------------------------------------------------------------------------------------------------
ADT Абстрактные типы данных: 
/
Односвязный список, Двухсвязный список, Стек, Очеред, Бинарное дерево
----------------------------------------------------------------------------------------------------------
STL : контейнеры, алгоритмы, итераторы, предикаты (функторы, алокаторы)
/
итератор - Класс(шаблон класса), который имитирует указатель на елементы контейнера
были придуманны что бы мы могли писать функции, которые работают со всеми контейнерами одинаков
----------------------------------------------------------------------------------------------------------
Алгоритм (в контексте STL)
/
Алгоритм (в контексте STL) это функции которая работает с контейнером через итератор
потому что итераторы предоставляют абстракцию по отношению ко всем контейнерам 
алгоритмы = Библиотека алгоритмов определяет функции для различных целей 
(например, поиск, сортировка, подсчёт, манипулирование), которые работают с диапазонами элементов. 
Обратите внимание, что диапазон определяется как [первый, последний), где последний ссылается на элемент, 
который находится после последнего элемента, который нужно проверить или изменить.
----------------------------------------------------------------------------------------------------------
предикат
/
функция которая возвращает bool, есть унарная и бинарная
----------------------------------------------------------------------------------------------------------
Алокатор
/
Алокатор = специализированный класс,
реализующий и инкапсулирующий малозначимые (с прикладной точки зрения) 
детали распределения и освобождения ресурсов компьютерной памяти.
----------------------------------------------------------------------------------------------------------
Функторы
/
класс, у которого перегружена операция ()
----------------------------------------------------------------------------------------------------------
контейнер
/
контейнер = шаблон класса который вмещает в себя любые данные одного типа и предоставляет
операции для манипуляции этими данными

контейнеры:
последовательные (Sequence) = (vector, array, list, deque, forward_list)
расположены один за одним, не обязательно в памяти, но линейный поиск подходит

асоциативные (associative) = (set, map, multiset, multimap)
на основе бинарного дерева, ассоциация в том, что есть ключ и он ассоциируется со значением
O(log n)

неупорядоченные асоциативные (unordered associative) = (unordered_set, unordered_map, unordered_multiset, unordered_unordered)
на основе хеш-таблиц, ассоциация в том, что есть ключ и он ассоциируется со значением

Адапторы контейнеров (Adaptors) = (stack, queue, priority_queue)
Адапторы - потому что они ограничивают определенные контейнеры, заставляя их вести себя так,
как будто это другие структуры данных
берется какой-то последовательный контейнер и его функционал огнаричен
----------------------------------------------------------------------------------------------------------
/
----------------------------------------------------------------------------------------------------------
